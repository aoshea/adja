{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","src/index.js","src/main.js","src/render.js","src/utils.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"script.js","sourceRoot":"/source/","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","var game = require('./main.js');\n\nvar g = Object.create(game);\ng.init();\n\nconsole.log('init!!');","\n\"use strict\";\n\n// require module dependencies\nvar render    = require('./render.js'),\n    utils     = require('./utils.js');\n    \nvar proxy = utils.proxy;\nvar raf   = utils.requestAnimFrame;\n  \nvar Constants = {  \n  FRICTION: 0.975,  \n  GRAVITY: 1.1,\n  MAX_PARTICLES: 2000,  \n  CURTAIN_COLS: 80,  \n  CURTAIN_ROWS: 18  \n};\n\nvar Particle = {        \n  \n  init: function (x, y) {\n    this.x = x;\n    this.y = y;\n    this.ax = 0;\n    this.ay = 0;\n  },\n  \n  update: function () {      \n    this.ax *= Constants.FRICTION;\n    this.ay *= Constants.FRICTION;\n    this.ay += Constants.GRAVITY;\n  \n    this.x += this.ax;\n    this.y += this.ay;\n  },\n  \n  clone: function () {\n    var p = Object.create(this);\n    p.init(this.x, this.y);\n    return p;\n  }\n  \n};\n\nvar Constraint = {\n  \n  init: function (rest, a, b) {\n    this.pA = a;\n    this.rest = rest;\n    if (!b) {\n      this.pB = a.clone();\n      this.pin = true;\n      return;\n    }\n    this.pB = b;\n  },\n  \n  getLine: function () {\n    return {\n      x0: this.pA.x, \n      y0: this.pA.y,\n      x1: this.pB.x,\n      y1: this.pB.y\n    };\n  },\n\n  update: function () {\n    var dx, dy, len, dist, ddx, ddy;\n  \n    dx = this.pA.x - this.pB.x;\n    dy = this.pA.y - this.pB.y;\n    \n    len = Math.sqrt(dx*dx + dy*dy);\n  \n    if (len === 0) len = 0.001;\n  \n    dist = 1 * (this.rest - len) * 0.5 * -1;\n\n    ddx = this.pB.x + dx * 0.5;\n    ddy = this.pB.y + dy * 0.5;\n  \n    dx /= len;\n    dy /= len;\n  \n    if (!this.pin) {\n      this.pB.x = ddx + dx * 0.5 * this.rest * -1;\n      this.pB.y = ddy + dy * 0.5 * this.rest * -1;\n  \n      this.pB.ax = this.pB.ax + dx * dist;\n      this.pB.ay = this.pB.ay + dy * dist;    \n    }\n    \n    this.pA.x = ddx + dx * 0.5 * this.rest;\n    this.pA.y = ddy + dy * 0.5 * this.rest;\n\n    this.pA.ax = this.pA.ax + dx * -dist;\n    this.pA.ay = this.pA.ay + dy * -dist;\n  }\n  \n};\n\nvar Game = {\n  \n  REST: 12,\n  \n  BOUNDARY: { x0: 0, x1: 480, y0:0, y1: 320 },\n  \n  init: function () {\n    this.canvas = document.getElementById('canvas');\n    this.originalWidth = this.canvas.width;\n    this.originalHeight = this.canvas.height;\n    render.init(this.canvas);  \n    this.reset();\n    document.onmousemove = proxy(this.handleMouseMove, this);\n    document.onmousedown = proxy(this.handleMouseDown, this);\n    document.onmouseup = proxy(this.handleMouseUp, this);\n    window.addEventListener('resize', proxy(this.handleResize, this));\n    raf(proxy(this.tick, this));\n    this.handleResize();\n  },\n  \n  draw: function () {\n    render.clear();\n    this.drawParticles();\n    this.drawConstraints();\n    render.flush();\n  },\n  \n  drawParticles: function () {\n    var p, i, len = this.numParticles;\n    for(i = 0; i < len; ++i) {\n      p = this.particles[i];\n      var size = 4;\n      render.drawRect(p.x-size/2, p.y-size/2, size, size);\n    }\n  },\n  \n  drawConstraints: function () {\n    var i, line, len = this.constraints.length;\n    for(i = 0; i < len; ++i) {\n      line = this.constraints[i].getLine();\n      render.drawLine(line.x0, line.y0, line.x1, line.y1);\n    }\n  },\n  \n  updateMouse: function () {\n    if (this.mouseDown) {\n      this.applyForceFrom(this.mouseX, this.mouseY, -1);\n    }\n  },\n  \n  update: function () {\n    this.updateMouse();\n    this.updateParticles();\n    this.updateConstraints();\n    \n  },\n  \n  updateParticles: function () {\n    var i, len = this.numParticles;\n    for(i = 0; i < len; ++i) {\n      this.particles[i].update();\n    }\n  }, \n  \n  updateConstraints: function () {\n    var i, len = this.constraints.length;\n    for(i = 0; i < len; ++i) {\n      this.constraints[i].update();\n    }\n  },\n  \n  tick: function () {\n    raf(proxy(this.tick, this));\n\n    if (!render.ready()) {\n      return;\n    }  \n    \n    this.update();\n    this.draw();\n    \n  },\n  \n  reset: function () {      \n    this.createParticles();\n    this.createCurtain(Constants.CURTAIN_COLS, Constants.CURTAIN_ROWS);\n  },\n\n  randInRange: function(range) {\n    return parseInt(Math.random()*range, 10);\n  },\n  \n  createParticles: function () {\n    var p, i, len = Constants.MAX_PARTICLES;\n    this.particles = [];\n    for(i = 0; i < len; ++i) {\n      p = Object.create(Particle);\n      p.init(0, 0);\n      this.particles.push(p);\n    }\n    this.numParticles = this.particles.length;\n  },\n  \n  createConstraint: function (pA, pB, constraints) {      \n    var constraint = Object.create(Constraint);\n    constraint.init(Game.REST, pA, pB);\n    constraints.push(constraint);\n  },\n  \n  pinConstraint: function (pA, constraints) {\n    var constraint = Object.create(Constraint);\n    constraint.init(1, pA);\n    constraints.push(constraint);\n  },\n  \n  createCurtain: function (cols, rows) {        \n    var x, y, i = 0;\n    this.constraints = [];    \n    for(x = 0; x < cols; ++x) {\n      for(y = 0; y < rows; ++y) {\n        if (i >= this.numParticles-1) return;\n        this.createConstraint(this.particles[i++], this.particles[i], this.constraints);\n        this.particles[i-1].x = (Game.BOUNDARY.x1 / 2) + (x * Game.REST);\n        this.particles[i-1].y = y * Game.REST;            \n        if (y === 0) {\n          this.pinConstraint(this.particles[i-1], this.constraints);          \n        }\n        if (x > 0) {\n          this.createConstraint(this.particles[i], this.particles[i-rows-1], this.constraints);\n        }\n      }\n      ++i;\n    }\n  }, \n  \n  applyForceFrom: function (x, y, mag) {\n    var dx, dy, deltaLen, p, i, len = this.numParticles;\n    for(i = 0; i < len; ++i) {\n      p = this.particles[i];\n      dx = p.x - x;\n      dy = p.y - y;\n      deltaLen = Math.sqrt(dx * dx + dy * dy);\n      dx /= deltaLen;\n      dy /= deltaLen;\n      p.ax += dx * mag;\n      p.ay += dy * mag;      \n    }     \n  },\n  \n  getNearestParticle: function (x, y) {\n    var dx, dy, i, len, delta = 1000, p;\n    for(i = 0; i < this.numParticles; ++i) {\n      dx = this.particles[i].x - x;\n      dy = this.particles[i].y - y;\n      len = Math.sqrt(dx * dx + dy * dy);\n      if (len < delta) {\n        p = this.particles[i];\n        delta = len;\n      }\n    }\n    return p;\n  },\n  \n  setMousePosition: function (x, y) {\n    var scaleX = this.canvas.width / this.originalWidth,\n        scaleY = this.canvas.height / this.originalHeight;\n        \n    this.mouseX = x / scaleX;\n    this.mouseY = y / scaleY;\n    \n    render.setMouse(this.mouseX, this.mouseY);\n  },\n  \n  handleMouseDown: function (e) {\n    this.mouseDown = true;  \n    this.setMousePosition(e.pageX, e.pageY); \n  },\n  \n  handleMouseUp: function () {\n    this.mouseDown = false;\n  },\n  \n  handleMouseMove: function (e) {\n    this.setMousePosition(e.pageX, e.pageY); \n  },\n  \n  handleResize: function () {      \n    this.canvas.width = document.documentElement.clientWidth;\n    this.canvas.height = document.documentElement.clientHeight;\n  }\n};\n\nmodule.exports = Game;","'use strict';\n    \n// Shaders \nvar shaderSource = {\n  vertex: '',\n  fragment: '',\n};\n\nvar stats = {\n  isReady: false\n};\n\nvar u_mouse = {\n  x:0,\n  y:0\n};\n\nvar gl, \n    shaderProgram, \n    canvasWidth, \n    canvasHeight, \n    vertices, \n    lineVertices,\n    colours, \n    vertexBuffer, \n    colourBuffer, \n    vertexPosAttrib, \n    vertexColourAttrib;\n\nfunction createBuffer() {\n  vertexColourAttrib = gl.getAttribLocation(shaderProgram, \"a_colour\");\n  gl.enableVertexAttribArray(vertexColourAttrib);\n\n  vertexPosAttrib = gl.getAttribLocation(shaderProgram, 'a_position');\n  gl.enableVertexAttribArray(vertexPosAttrib);\n\n  var resolutionLocation = gl.getUniformLocation(shaderProgram, 'u_resolution');\n  gl.uniform2f(resolutionLocation, canvasWidth, canvasHeight);\n  \n  //var mouseLocation = gl.getUniformLocation(shaderProgram, 'u_mouse');\n  //gl.uniform2f(mouseLocation, u_mouse.x, u_mouse.y);\n\n  // create buffer\n  vertexBuffer = gl.createBuffer();\n  colourBuffer = gl.createBuffer();\n\n  //gl.enable(gl.BLEND);\n  //gl.disable(gl.DEPTH_TEST);\n}\n\n\n// Load glsl code into shaders object \nfunction loadShaders( shaders, callback ) {\n\n  var queue = 0;\n  \n  function loadHandler( name, req ) {\n    console.log('loaded', name);\n    \n    return function () {      \n      shaders[name] = req.responseText;\n      if ( --queue <= 0 ) callback();\n    }\n  }\n\n  for(var name in shaders) {\n  \n    queue++;\n    \n    console.log('add to queue');\n  \n    var req = new XMLHttpRequest();\n    req.onload = loadHandler( name, req );\n    req.open( 'get', 'glsl/' + name + '.glsl', true);\n    req.send();\n  \n  }\n}\n\n// Create and compile shader from source \nfunction createShader( source, type ) {\n\n  var shader = gl.createShader( type );\n\n  gl.shaderSource( shader, source );\n  gl.compileShader( shader );\n\n  if ( !gl.getShaderParameter( shader, gl.COMPILE_STATUS) ) {\n    throw gl.getShaderInfoLog( shader );\n  }\n\n  return shader;\n}\n\n// Create shader program and create & link shaders \nfunction createProgram( vertexSrc, fragmentSrc ) {\n\n  var vertexShader, fragmentShader, program;\n\n  vertexShader = createShader( vertexSrc, gl.VERTEX_SHADER ),\n  fragmentShader = createShader( fragmentSrc, gl.FRAGMENT_SHADER );\n\n  program = gl.createProgram();\n \n  gl.attachShader( program, fragmentShader );\n  gl.attachShader( program, vertexShader );\n  gl.linkProgram( program );\n\n  if ( !gl.getProgramParameter( program, gl.LINK_STATUS) ) {\n    throw gl.getProgramInfoLog( program );\n  }\n    \n  return program;  \n}\n\nfunction setupShaders() {\n  console.log('seupthshader', shaderSource);\n  \n  shaderProgram = createProgram(shaderSource.vertex, shaderSource.fragment);\n  gl.useProgram(shaderProgram);\n  \n  createBuffer();\n  \n  stats.isReady = true;\n}\n\nfunction init(canvas) {\n  canvasWidth = canvas.width;\n  canvasHeight = canvas.height;\n  \n  gl = null;\n\n  try {\n    gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');\n  } catch (e) {}\n\n  if (!gl) {\n    console.warn('Unable to initialise WebGL');\n    return;\n  }\n  \n  loadShaders(shaderSource, setupShaders);\n    \n  //initShaders(gl, '2d-fragment-shader', '2d-vertex-shader');\n  //createBuffer();\n}\n\nfunction setMouse(x,y){\n  u_mouse.x = x;\n  u_mouse.y = y;  \n}\n\nfunction setRect(x, y, width, height) {\n  var x1 = x + width, y1 = y + height;\n  vertices.push(x, y, x1, y, x, y1, x, y1, x1, y, x1, y1);\n  \n  var scale = y / gl.canvas.height;\n\n  colours.push(\n          1.0, 0.0, 0.0, scale,\n          0.0, 1.0, 0.0, scale,\n          0.0, 1.0, 1.0, scale,\n          0.0, 1.0, 1.0, scale,              \n          0.0, 1.0, 0.0, scale,\n          1.0, 0.0, 0.0, scale                      \n  );\n}\n\nfunction drawRect(x, y, width, height) {\n  if (!vertices) vertices = [];            \n  setRect(x, y, width, height);\n}\n\nfunction drawLine(x0, y0, x1, y1) {\n  lineVertices.push(x0, y0, x1, y1);\n}\n\nfunction clear() {\n  vertices = [];\n  lineVertices = [];\n  colours = [];\n  gl.clear(gl.COLOR_BUFFER_BIT);\n}\n\nfunction flush() {\n  \n  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n  \n  //var mouseLocation = gl.getUniformLocation(shaderProgram, 'u_mouse');\n  //gl.uniform2f(mouseLocation, u_mouse.x, u_mouse.y);\n  \n  //gl.blendFunc(gl.SRC_ALPHA, gl.ONE);\n\n  gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\n  gl.vertexAttribPointer(vertexPosAttrib, 2, gl.FLOAT, false, 0, 0);  \n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\n  \n  gl.bindBuffer(gl.ARRAY_BUFFER, colourBuffer);\n  gl.vertexAttribPointer(vertexColourAttrib, 4, gl.FLOAT, false, 0, 0);\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colours), gl.STATIC_DRAW);\n  \n  gl.drawArrays(gl.TRIANGLES, 0, parseInt(vertices.length/2, 10)); \n  \n  gl.bindBuffer(gl.ARRAY_BUFFER, colourBuffer);\n  gl.vertexAttribPointer(vertexColourAttrib, 4, gl.FLOAT, false, 0, 0);\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colours), gl.STATIC_DRAW); \n  \n  gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\n  gl.vertexAttribPointer(vertexPosAttrib, 2, gl.FLOAT, false, 0, 0);  \n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(lineVertices), gl.STATIC_DRAW);\n    \n  gl.drawArrays(gl.LINES, 0, lineVertices.length / 2)\n}\n\n\n    \nmodule.exports = {\n  ready: function () {\n    return stats.isReady;\n  },\n  init: init,\n  clear: clear,\n  flush: flush,\n  drawRect: drawRect,\n  drawLine: drawLine,\n  setMouse: setMouse\n}; ","/* Helper method for preserving scope */\nvar proxy = function () {\n  var args = Array.prototype.slice.call(arguments),\n      fn = args.shift(),\n      context = args.shift();\n    \n  return function () {\n    fn.apply(context, args.concat(Array.prototype.slice.call(arguments)));\n  };\n};\n\n/* Polyfill for requestAnimationFrame */\nvar requestAnimFrame = window.requestAnimationFrame || \n                       window.webkitRequestAnimationFrame || \n                       window.oRequestAnimationFrame || \n                       window.msRequestAnimationFrame || \n                       window.mozRequestAnimationFrame || \n                       function (callback) {\n                         return window.setTimeout(callback, 1000/60);\n                       };\n                       \nmodule.exports = {\n  proxy: proxy,\n  requestAnimFrame: requestAnimFrame\n};"]}